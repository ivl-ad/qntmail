<!doctype html>
<html lang="en">
<head>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#070A12" />
  <meta name="description" content="QNTMail ‚Äî secure email delivery at global scale." />

  <title>QNTMail ‚Äî Secure Email, Worldwide</title>

<link rel="icon" type="image/png" sizes="32x32" href="logo.png">
<link rel="icon" type="image/png" sizes="192x192" href="logo.png">
<link rel="apple-touch-icon" href="logo.png">



  <style>
    :root{
      --bg0:#050712;
      --bg1:#070A12;
      --panel: rgba(255,255,255,0.06);
      --panel2: rgba(255,255,255,0.10);
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.70);
      --muted2: rgba(255,255,255,0.55);
      --accent: #6EE7FF;
      --accent2:#9B7BFF;
      --ok: #6DFFB1;
      --shadow: rgba(0,0,0,0.35);
      --border: rgba(255,255,255,0.12);
      --glow: rgba(110,231,255,0.35);
      --radius: 18px;
      --radius2: 28px;
      --maxw: 1120px;
      --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 900px at 60% 20%, rgba(155,123,255,0.15), transparent 55%),
                  radial-gradient(900px 650px at 20% 30%, rgba(110,231,255,0.12), transparent 50%),
                  linear-gradient(180deg, var(--bg0), var(--bg1));
      color: var(--text);
      font-family: var(--font);
      overflow-x: hidden;
    }

    /* Fullscreen WebGL canvas */
    #stage {
  position: fixed;
  inset: 0;
  width: 100%;
  height: 100%;
  display: block;
  z-index: 0;
  outline: none;

  pointer-events: auto;   /* allows mouse interaction */
  touch-action: none;     /* prevents scroll hijacking */
}


    /* Soft vignette overlay */
    .vignette {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 1;
      background:
        radial-gradient(1200px 700px at 50% 35%, rgba(0,0,0,0.10), rgba(0,0,0,0.65)),
        radial-gradient(800px 500px at 70% 20%, transparent, rgba(0,0,0,0.55));
      mix-blend-mode: multiply;
    }

    /* Top nav */
    header {
  position: sticky;
  top: 0;
  z-index: 5;

  width: 100%;
  display: flex;
  justify-content: center;

  padding: 16px 18px;

  background: transparent; /* ALWAYS transparent */
  pointer-events: auto;
}



    .nav {
      width: min(var(--maxw), calc(100% - 36px));
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 14px;
    }
    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
      text-decoration: none;
      color: var(--text);
    }
    .logo {
      width: 36px;
      height: 36px;
      border-radius: 12px;
      background:
        radial-gradient(circle at 35% 35%, rgba(110,231,255,0.95), rgba(110,231,255,0.15) 55%, transparent 70%),
        radial-gradient(circle at 70% 70%, rgba(155,123,255,0.85), rgba(155,123,255,0.10) 60%, transparent 75%),
        linear-gradient(135deg, rgba(255,255,255,0.18), rgba(255,255,255,0.02));
      border: 1px solid var(--border);
      box-shadow: 0 10px 30px var(--shadow), 0 0 30px rgba(110,231,255,0.12);
    }
    .brand span {
      font-weight: 650;
      letter-spacing: 0.2px;
      font-size: 15px;
      opacity: 0.95;
    }
    .navlinks {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .pill {
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      color: var(--text);
      text-decoration: none;
      font-size: 13px;
      opacity: 0.9;
      transition: transform .15s ease, background .15s ease, opacity .15s ease;
      backdrop-filter: blur(10px);
    }
    .pill:hover { transform: translateY(-1px); background: rgba(255,255,255,0.07); opacity: 1; }
    .pill.primary {
      border-color: rgba(110,231,255,0.35);
      background: linear-gradient(135deg, rgba(110,231,255,0.25), rgba(155,123,255,0.18));
      box-shadow: 0 12px 36px rgba(110,231,255,0.12);
    }

    /* Hero */
    main {
  position: relative;
  z-index: 2;
  width: 100%;
  display: block; /* ‚Üê CRITICAL */
}


	
	
	
	/* The globe stage takes the whole first viewport */
.stageSpacer {
  height: min(92vh, 820px);
  width: 100%;
  position: relative;

  padding-top: 80px; /* matches topMask height */
}




/* Content that scrolls below the stage */
.content {
  position: relative;
  z-index: 2;
  width: 100%;
  display: block; /* ‚Üê NOT FLEX */
  padding: 80px 18px 90px;
}



/* Make anchor scrolling land nicely below the fixed-ish top UI */
#security, #network, #get-started {
  scroll-margin-top: 90px;
}

	
	
	
	

    .hero {
      padding: 22px 22px 18px;
      border-radius: var(--radius2);
      background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
      border: 1px solid var(--border);
      box-shadow: 0 24px 70px rgba(0,0,0,0.35);
      backdrop-filter: blur(12px);
    }
    h1{
      margin: 0 0 10px;
      font-size: clamp(34px, 4vw, 54px);
      line-height: 1.04;
      letter-spacing: -0.7px;
    }
    .sub {
      margin: 0 0 18px;
      font-size: 15.5px;
      line-height: 1.55;
      color: var(--muted);
      max-width: 56ch;
    }
    .ctaRow {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 6px;
    }
    .btn {
      appearance: none;
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px 14px;
      background: rgba(255,255,255,0.05);
      color: var(--text);
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      backdrop-filter: blur(10px);
    }
    .btn:hover { transform: translateY(-1px); background: rgba(255,255,255,0.08); border-color: rgba(255,255,255,0.18); }
    .btn.primary {
      border-color: rgba(110,231,255,0.45);
      background: linear-gradient(135deg, rgba(110,231,255,0.28), rgba(155,123,255,0.18));
      box-shadow: 0 16px 44px rgba(110,231,255,0.14);
    }
    .fine {
      margin: 14px 0 0;
      color: var(--muted2);
      font-size: 12.5px;
      line-height: 1.4;
    }

    
    .card {
      border-radius: var(--radius);
      background: rgba(255,255,255,0.045);
      border: 1px solid var(--border);
      box-shadow: 0 22px 55px rgba(0,0,0,0.30);
      backdrop-filter: blur(12px);
      padding: 16px 16px 14px;
    }
    .card h3 {
      margin: 0 0 6px;
      font-size: 14px;
      letter-spacing: 0.2px;
    }
    .card p {
      margin: 0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.45;
    }
    .statRow {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    .stat {
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.035);
    }
    .stat .k {
      font-size: 12px;
      color: var(--muted2);
      margin-bottom: 4px;
    }
    .stat .v {
      font-size: 15px;
      font-weight: 700;
    }

    /* Footer */
    footer {
      position: relative;
      z-index: 2;
      display: flex;
      justify-content: center;
      padding: 0 18px 26px;
      color: var(--muted2);
      font-size: 12.5px;
    }
    .foot {
      width: min(var(--maxw), calc(100% - 36px));
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      opacity: 0.95;
    }
    .dot {
      width: 7px; height: 7px; border-radius: 999px;
      background: radial-gradient(circle at 30% 30%, rgba(109,255,177,0.95), rgba(109,255,177,0.20));
      box-shadow: 0 0 18px rgba(109,255,177,0.25);
      display: inline-block;
      margin-right: 8px;
      transform: translateY(-1px);
    }

    /* Little HUD badge */
    .hud {
      position: fixed;
      right: 14px;
      bottom: 14px;
      z-index: 3;
      border-radius: 999px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.28);
      backdrop-filter: blur(10px);
      color: rgba(255,255,255,0.75);
      font-size: 12px;
      display: flex;
      gap: 10px;
      align-items: center;
      user-select: none;
    }
    .hud button{
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      color: rgba(255,255,255,0.85);
      border-radius: 999px;
      padding: 6px 9px;
      cursor: pointer;
      font-size: 12px;
    }
    .hud button:hover{ background: rgba(255,255,255,0.08); }
	
	
	/* ===== HERO ABOVE GLOBE ===== */
.heroAbove {
  position: absolute;
  top: 14vh;
  left: 50%;
  transform: translateX(-50%);
  width: min(720px, calc(100% - 36px));
  text-align: center;
  z-index: 2;
}

.heroAbove .sub {
  text-align: center;
  margin-left: auto;
  margin-right: auto;
  max-width: 72ch;
}



.heroAbove .ctaRow {
  justify-content: center;
}

/* ===== FEATURES BELOW GLOBE (FIXED) ===== */
.features {
  width: min(var(--maxw), calc(100% - 36px));
  margin: 0 auto;
  display: grid;
  grid-template-columns: repeat(2, minmax(320px, 1fr));
  gap: 22px;
  align-items: stretch;
}

/* Center cards visually */
.features .card {
  text-align: left;
}

/* Stack cleanly on mobile */
@media (max-width: 820px) {
  .features {
    grid-template-columns: 1fr;
  }
}



/* ===== TOP CONTENT MASK (KEY FIX) ===== */
.topMask {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 80px; /* same height as header area */

  z-index: 3;

  /* hides page content but not the canvas */
  background: linear-gradient(
    180deg,
    rgba(7,10,18,1),
    rgba(7,10,18,0.85),
    rgba(7,10,18,0)
  );

  pointer-events: none;
}




/* ===== MODAL SYSTEM ===== */
.modalOverlay {
  position: fixed;
  inset: 0;
  z-index: 20;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(5,7,18,0.65);
  backdrop-filter: blur(10px);
}

.modalOverlay.active {
  display: flex;
}

.modalCard {
  width: min(720px, calc(100% - 32px));
  max-height: 85vh;
  overflow-y: auto;

  border-radius: var(--radius2);
  padding: 22px 22px 20px;

  background:
    linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
  border: 1px solid var(--border);
  box-shadow:
    0 30px 80px rgba(0,0,0,0.55),
    0 0 60px rgba(110,231,255,0.12);

  color: var(--text);
}

.modalClose {
  position: sticky;
  top: 0;
  float: right;
  margin-left: auto;

  appearance: none;
  border: 1px solid var(--border);
  background: rgba(255,255,255,0.06);
  color: var(--text);
  border-radius: 999px;
  width: 32px;
  height: 32px;
  cursor: pointer;
  font-size: 18px;
}

.modalCard h2 {
  margin-top: 6px;
  margin-bottom: 10px;
  font-size: 26px;
  letter-spacing: -0.4px;
}

.modalCard p {
  color: var(--muted);
  line-height: 1.6;
  font-size: 14.5px;
}

.modalSection {
  margin-top: 18px;
  padding-top: 14px;
  border-top: 1px solid rgba(255,255,255,0.08);
}

.modalList {
  padding-left: 18px;
  color: var(--muted);
}

.modalList li {
  margin: 6px 0;
}


/* ===== WAITLIST FORM ===== */
.waitlistForm {
  max-width: 420px;
  margin: 18px auto 0;
  display: grid;
  gap: 14px;
}

.waitlistField {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.waitlistLabel {
  font-size: 12px;
  color: var(--muted2);
  letter-spacing: 0.2px;
}

.waitlistInput {
  width: 100%;
  padding: 12px 14px;
  border-radius: 14px;
  border: 1px solid var(--border);
  background: rgba(255,255,255,0.05);
  color: var(--text);
  font-size: 14px;
  backdrop-filter: blur(10px);
  outline: none;
  transition:
    border-color 0.15s ease,
    box-shadow 0.15s ease,
    background 0.15s ease;
}

.waitlistInput::placeholder {
  color: rgba(255,255,255,0.45);
}

.waitlistInput:focus {
  border-color: rgba(110,231,255,0.45);
  background: rgba(255,255,255,0.08);
  box-shadow:
    0 0 0 2px rgba(110,231,255,0.15),
    0 12px 32px rgba(110,231,255,0.18);
}

.waitlistInput[type="text"] {
  letter-spacing: 0.12em;
  text-transform: uppercase;
}

.waitlistSubmit {
  margin-top: 6px;
  align-self: center;
  min-width: 180px;
}



.logoImg {
image-rendering: -webkit-optimize-contrast;
filter: brightness(1.15) contrast(1.1);
  width: 36px;
  height: 36px;
  border-radius: 12px;
  padding: 6px;

  background:
    radial-gradient(circle at 35% 35%, rgba(110,231,255,0.25), transparent 60%),
    radial-gradient(circle at 70% 70%, rgba(155,123,255,0.22), transparent 65%),
    linear-gradient(135deg, rgba(255,255,255,0.14), rgba(255,255,255,0.02));

  border: 1px solid var(--border);

  box-shadow:
    0 10px 30px var(--shadow),
    0 0 28px rgba(110,231,255,0.18);

  object-fit: contain;
  display: block;
}


.logoWordmark {
  height: 36px;           /* THIS defines the size */
  width: auto;            /* Let width scale naturally */
  display: block;

  /* Remove icon-style padding & box */
  padding: 0;
  background: none;
  border: none;
  box-shadow: none;

  object-fit: contain;
  //outline: 2px solid red;
}

.brand {
  padding: 6px 10px;
  border-radius: 14px;

  background:
    radial-gradient(circle at 30% 30%, rgba(110,231,255,0.18), transparent 60%),
    linear-gradient(135deg, rgba(255,255,255,0.12), rgba(255,255,255,0.02));

  border: 1px solid var(--border);

  box-shadow:
    0 10px 30px var(--shadow),
    0 0 28px rgba(110,231,255,0.16);
	
	//outline: 2px solid lime;
}

	
	
  </style>
</head>

<body>
  <canvas id="stage" aria-label="Animated 3D globe with secure email packets"></canvas>
  <div class="vignette"></div>
  <div class="topMask"></div>


  <header>
    <nav class="nav">
      <a class="brand" href="#top" aria-label="QNTMail home">
  <img
    src="logo3.png"
    alt="QNTMail"
    class="logoWordmark"
  />
</a>

      <div class="navlinks">
        <a class="pill" href="#security">Security</a>
        <a class="pill" href="#network">Network</a>
		<!--a class="pill" href="#contact">Contact</a-->
        <a class="pill primary" href="#get-started">Get started</a>
      </div>
    </nav>
  </header>

  <main>
  <!-- Full-viewport stage area (globe only). Nav stays on top. -->
  <!-- Globe viewport -->
<section class="stageSpacer" id="top">
  <div class="hero heroAbove">
    <h1>Secure email, delivered worldwide.</h1>
    <p class="sub">
      QNTMail visualizes global delivery in real time ‚Äî encrypted messages traveling across a resilient network.
      Built for privacy, speed, and reliability.
    </p>

    <div class="ctaRow">
      <button class="btn primary" id="ctaPrimary">Join the waitlist</button>
      <button class="btn" id="ctaSecondary">View security model</button>
    </div>
  </div>
</section>

<!-- Content BELOW globe -->
<section class="content">
  <div class="features">

    <div class="card" id="security">
      <h3>End-to-end encrypted by design</h3>
      <p>
        Packets are represented as signed, encrypted payloads ‚Äî routed efficiently while keeping content private.
      </p>
      <div class="statRow">
        <div class="stat">
          <div class="k">Transport</div>
          <div class="v">TLS + Forward Secrecy</div>
        </div>
        <div class="stat">
          <div class="k">Payload</div>
          <div class="v">E2E Encryption</div>
        </div>
      </div>
    </div>

    <div class="card" id="network">
      <h3>Global routing visualization</h3>
      <p>
        Animated arcs show messages moving between regions with jitter, speed variance, and signature glow.
      </p>
      <div class="statRow">
        <div class="stat">
          <div class="k">Uptime goal</div>
          <div class="v">99.99%</div>
        </div>
        <div class="stat">
          <div class="k">Latency</div>
          <div class="v">Low & consistent</div>
        </div>
      </div>
    </div>

  </div>
</section>

</main>


  <footer>
    <div class="foot">
      <div><span class="dot"></span>Network active ‚Ä¢ secure channels established</div>
      <div>¬© <span id="year"></span> QNTMail</div>
    </div>
  </footer>
  
  
  
    <!-- Modal Overlay -->
<div id="modalOverlay" class="modalOverlay" aria-hidden="true">
  <div class="modalCard" role="dialog" aria-modal="true">
    <button class="modalClose" aria-label="Close">√ó</button>
    <div id="modalContent"></div>
  </div>
</div>
  
  

  <div class="hud" role="status" aria-live="polite">
    <span id="hudText">Quality: High</span>
    <button id="toggleQuality" type="button">Toggle</button>
    <button id="toggleMotion" type="button">Motion</button>
  </div>
  
  
  


  
  

  <!-- Three.js (module) -->
  <script type="module" defer>
  
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

	const EARTH_TEXTURE_URL =
  "https://cdn.jsdelivr.net/gh/ivl-ad/i@main/BlackMarble_2016_01deg.jpg";


    // -----------------------------
    // Utilities (no allocations in hot paths)
    // -----------------------------
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const lerp = (a, b, t) => a + (b - a) * t;

    // Convert lat/lon to unit sphere (Y up)
    function latLonToVec3(latDeg, lonDeg, outVec) {
  const lat = THREE.MathUtils.degToRad(latDeg);
  const lon = THREE.MathUtils.degToRad(-lonDeg); // ‚úÖ FIX: invert longitude

  const cosLat = Math.cos(lat);

  outVec.set(
    cosLat * Math.cos(lon),
    Math.sin(lat),
    cosLat * Math.sin(lon)
  );

  return outVec;
}











    // Great-circle-ish arc control point:
    // Midpoint pushed outward to create a nice arc above the surface.
    function computeArcPoints(a, b, radius, height, segments, outArray) {
      // a and b are unit vectors; outArray is Float32Array length (segments+1)*3
      const vA = _v1.copy(a);
      const vB = _v2.copy(b);

      const dot = clamp(vA.dot(vB), -1, 1);
      const angle = Math.acos(dot);

      // If points are almost the same, just linearly return
      const useSlerp = angle > 1e-4;

      for (let i = 0; i <= segments; i++) {
        const t = i / segments;

        let p;
        if (useSlerp) {
          // Slerp without allocating: use Quaternion-ish slerp in vector space
          // THREE.Vector3 has .lerpVectors + normalize approximation:
          // We'll do a proper slerp formula:
          const sinAngle = Math.sin(angle);
          const w1 = Math.sin((1 - t) * angle) / sinAngle;
          const w2 = Math.sin(t * angle) / sinAngle;
          p = _v3.set(
            vA.x * w1 + vB.x * w2,
            vA.y * w1 + vB.y * w2,
            vA.z * w1 + vB.z * w2
          ).normalize();
        } else {
          p = _v3.copy(vA).lerp(vB, t).normalize();
        }

        // Arc lift: bell curve (0 at ends, 1 at middle)
        const lift = Math.sin(Math.PI * t);
        const r = radius + height * lift;

        outArray[i*3 + 0] = p.x * r;
        outArray[i*3 + 1] = p.y * r;
        outArray[i*3 + 2] = p.z * r;
      }
    }

    // -----------------------------
    // Config / Quality
    // -----------------------------
	const textureLoader = new THREE.TextureLoader();
let earthTexture = null;

function loadEarthTexture(onReady) {
  if (earthTexture) {
    onReady(earthTexture);
    return;
  }

  textureLoader.load(
    EARTH_TEXTURE_URL,
    (tex) => {
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.flipY = true;
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();

      earthTexture = tex;

      // üîç DEBUG ‚Äî THIS IS THE LINE YOU ASKED ABOUT
      console.log(
        "Earth texture loaded:",
        tex.image?.width,
        tex.image?.height,
        tex.image
      );

      onReady(tex);
    },
    undefined,
    (err) => {
      console.error("Earth texture failed to load", err);
    }
  );
}









    const prefersReducedMotion = window.matchMedia?.("(prefers-reduced-motion: reduce)")?.matches ?? false;

    const QUALITY = {
      high: {
        dprCap: 1.75,
        globeSeg: 96,
        stars: 2500,
        arcCount: 34,
        arcSegments: 84,
        packetsPerArc: 10,
      },
      low: {
        dprCap: 1.25,
        globeSeg: 64,
        stars: 1200,
        arcCount: 22,
        arcSegments: 64,
        packetsPerArc: 7,
      }
    };

    let qualityMode = "high";
    let motionEnabled = !prefersReducedMotion;

    // -----------------------------
    // Scene setup
    // -----------------------------
	
	
	// ===== MODAL CONTROLLER =====
const modalOverlay = document.getElementById("modalOverlay");
const modalContent = document.getElementById("modalContent");
const modalClose = document.querySelector(".modalClose");

function openModal(html) {
  modalContent.innerHTML = html;
  modalOverlay.classList.add("active");
  modalOverlay.setAttribute("aria-hidden", "false");
}

function closeModal() {
  modalOverlay.classList.remove("active");
  modalOverlay.setAttribute("aria-hidden", "true");
  modalContent.innerHTML = "";
}

modalClose.addEventListener("click", closeModal);
modalOverlay.addEventListener("click", e => {
  if (e.target === modalOverlay) closeModal();
});

	
	
	
	
    const canvas = document.getElementById("stage");
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
      powerPreference: "high-performance"
    });
    renderer.setClearColor(0x000000, 0);

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 200);
    camera.position.set(0, 1.1, 4.25);

    const controls = new OrbitControls(camera, canvas);
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.rotateSpeed = 0.9;   // faster drag rotation
controls.zoomSpeed = 0.6;
controls.enablePan = false;
controls.enableZoom = false;  // prevents scroll-wheel conflict


    // Lights
    const key = new THREE.DirectionalLight(0xffffff, 1.35);
    key.position.set(5, 3, 4);
    scene.add(key);

    const fill = new THREE.DirectionalLight(0x88aaff, 0.40);
    fill.position.set(-4, -2, -3);
    scene.add(fill);

    const amb = new THREE.AmbientLight(0x334466, 0.55);
    scene.add(amb);

    // -----------------------------
    // Background Stars (Points)
    // -----------------------------
    let stars = null;

    function createStars(count) {
      if (stars) {
        scene.remove(stars);
        stars.geometry.dispose();
        stars.material.dispose();
        stars = null;
      }
      const geom = new THREE.BufferGeometry();
      const pos = new Float32Array(count * 3);

      // Random sphere shell distribution
      for (let i = 0; i < count; i++) {
        const r = lerp(20, 55, Math.random());
        const u = Math.random() * 2 - 1;
        const t = Math.random() * Math.PI * 2;
        const s = Math.sqrt(1 - u*u);
        pos[i*3 + 0] = r * s * Math.cos(t);
        pos[i*3 + 1] = r * u;
        pos[i*3 + 2] = r * s * Math.sin(t);
      }
      geom.setAttribute("position", new THREE.BufferAttribute(pos, 3));

      const mat = new THREE.PointsMaterial({
        size: 0.06,
        sizeAttenuation: true,
        transparent: true,
        opacity: 0.85,
        depthWrite: false
      });

      stars = new THREE.Points(geom, mat);
      scene.add(stars);
    }

    // -----------------------------
    // Globe + Atmosphere
    // -----------------------------
    let globe = null;
    let atmosphere = null;
    let gridLines = null;





function createGlobe(seg) {
  if (globe) {
    scene.remove(globe, atmosphere, gridLines);
    globe.geometry.dispose();
    globe.material.dispose();
    atmosphere.geometry.dispose();
    atmosphere.material.dispose();
    gridLines.geometry.dispose();
    gridLines.material.dispose();
    globe = atmosphere = gridLines = null;
  }

  const radius = 1.35;

  const globeGeom = new THREE.SphereGeometry(radius, seg, seg);

  const globeMat = new THREE.MeshStandardMaterial({
    color: 0x0a1326,
    metalness: 0.15,
    roughness: 0.85
  });

  globe = new THREE.Mesh(globeGeom, globeMat);
  scene.add(globe);
  //globe.rotation.y = Math.PI; // align Black Marble longitude


  loadEarthTexture((tex) => {
    globe.material.map = tex;
globe.material.emissiveMap = tex;
globe.material.emissive.set(0xffffff);
globe.material.emissiveIntensity = 1.25;
globe.material.needsUpdate = true;

  });

  // Grid
  const wireGeom = new THREE.SphereGeometry(radius + 0.002, Math.floor(seg * 0.85), Math.floor(seg * 0.85));
  const wireMat = new THREE.MeshBasicMaterial({
    color: 0x6ee7ff,
    transparent: true,
    opacity: 0.085,
    wireframe: true,
    depthWrite: false
  });
  gridLines = new THREE.Mesh(wireGeom, wireMat);
  
  scene.add(gridLines);

  // Atmosphere
  const atmoGeom = new THREE.SphereGeometry(radius * 1.035, seg, seg);
  const atmoMat = new THREE.MeshBasicMaterial({
    color: 0x6ee7ff,
    transparent: true,
    opacity: 0.12,
    blending: THREE.AdditiveBlending,
    side: THREE.BackSide,
    depthWrite: false
  });
  atmosphere = new THREE.Mesh(atmoGeom, atmoMat);
  scene.add(atmosphere);

  return radius;
}






    // -----------------------------
    // Arcs + Packets (Instanced)
    // -----------------------------
    let arcGroup = null;
    let packetMesh = null;
    let arcs = []; // each arc: { points: Float32Array, segments, offset, speed, hue, active }
    let packetData = null; // typed arrays for instance attributes

    const _v1 = new THREE.Vector3();
    const _v2 = new THREE.Vector3();
    const _v3 = new THREE.Vector3();
    const _tmp = new THREE.Vector3();
    const _tmp2 = new THREE.Vector3();
    const _mat4 = new THREE.Matrix4();
    const _quat = new THREE.Quaternion();
    const _up = new THREE.Vector3(0, 1, 0);
	


    function createArcsAndPackets(radius, cfg) {
      // Cleanup
      if (arcGroup) {
        scene.remove(arcGroup);
        arcGroup.traverse(obj => {
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) obj.material.dispose();
        });
      }
      arcGroup = new THREE.Group();
      globe.add(arcGroup);
      arcs = [];

      // "Network hubs" (approx lat/lon, not exact city-level)
      const hubs = [
        [37.77, -122.42], // West US
        [40.71, -74.00],  // East US
        [51.51, -0.12],   // London
        [48.86, 2.35],    // Paris
        [52.52, 13.40],   // Berlin
        [25.20, 55.27],   // Dubai
        [19.07, 72.88],   // Mumbai
        [1.35, 103.82],   // Singapore
        [35.68, 139.76],  // Tokyo
        [22.32, 114.17],  // Hong Kong
        [-33.87, 151.21], // Sydney
        [-23.55, -46.63], // Sao Paulo
        [-26.20, 28.04],  // Johannesburg
      ];

      // Arc line material (additive + translucent)
      const arcMat = new THREE.LineBasicMaterial({
        color: 0x6ee7ff,
        transparent: true,
        opacity: 0.20,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      // Build arcs
      const arcCount = cfg.arcCount;
      const segments = cfg.arcSegments;

      // Pre-allocate line geometry per arc (efficient enough at these sizes)
      for (let i = 0; i < arcCount; i++) {
        const aHub = hubs[(Math.random() * hubs.length) | 0];
        let bHub = hubs[(Math.random() * hubs.length) | 0];
        // ensure different
        if (bHub === aHub) bHub = hubs[(Math.random() * hubs.length) | 0];

        const a = latLonToVec3(aHub[0], aHub[1], _v1).clone();
        const b = latLonToVec3(bHub[0], bHub[1], _v2).clone();

        const pts = new Float32Array((segments + 1) * 3);

        // arc height scales with distance
        const dot = clamp(a.dot(b), -1, 1);
        const ang = Math.acos(dot); // 0..pi
        const height = lerp(0.10, 0.55, clamp(ang / Math.PI, 0, 1));

        computeArcPoints(a, b, radius + 0.01, height, segments, pts);

        const geom = new THREE.BufferGeometry();
        geom.setAttribute("position", new THREE.BufferAttribute(pts, 3));

        // Slightly vary arc color by arc index using HSL
        const col = new THREE.Color().setHSL(lerp(0.52, 0.78, Math.random()), 0.95, 0.62);
        const mat = arcMat.clone();
        mat.color = col;
        mat.opacity = lerp(0.12, 0.26, Math.random());

        const line = new THREE.Line(geom, mat);
        arcGroup.add(line);

        arcs.push({
          points: pts,
          segments,
          speed: lerp(0.09, 0.22, Math.random()), // progression per second
          offset: Math.random(),                  // starting phase
          hue: col.getHSL({h:0,s:0,l:0}).h,
          active: true
        });
      }

      // Packets: instanced small "envelope" capsules
      const packetsPerArc = cfg.packetsPerArc;
      const totalPackets = arcCount * packetsPerArc;

      // Packet geometry: tiny capsule-ish via box + beveled illusion (simple = fast)
      const pktGeom = new THREE.BoxGeometry(0.028, 0.018, 0.06);
      const pktMat = new THREE.MeshBasicMaterial({
        color: 0x9b7bff,
        transparent: true,
        opacity: 0.92,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      packetMesh = new THREE.InstancedMesh(pktGeom, pktMat, totalPackets);
      packetMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

      // Per-instance color buffer (faster than multiple materials)
      const colorAttr = new THREE.InstancedBufferAttribute(new Float32Array(totalPackets * 3), 3);
      packetMesh.instanceColor = colorAttr;

      // Store packet simulation state in typed arrays for speed
      packetData = {
        arcIndex: new Uint16Array(totalPackets),
        phase: new Float32Array(totalPackets),
        speedMul: new Float32Array(totalPackets),
        jitter: new Float32Array(totalPackets),
        opacity: new Float32Array(totalPackets)
      };

      // Initialize packets distributed across arcs
      let idx = 0;
      for (let a = 0; a < arcCount; a++) {
        const baseHue = arcs[a].hue;
        for (let p = 0; p < packetsPerArc; p++) {
          packetData.arcIndex[idx] = a;
          packetData.phase[idx] = (p / packetsPerArc + Math.random() * 0.08) % 1;
          packetData.speedMul[idx] = lerp(0.65, 1.35, Math.random());
          packetData.jitter[idx] = lerp(0.0, 1.0, Math.random());
          packetData.opacity[idx] = lerp(0.55, 1.0, Math.random());

          const c = new THREE.Color().setHSL(
            clamp(baseHue + lerp(-0.05, 0.05, Math.random()), 0, 1),
            0.95,
            lerp(0.55, 0.72, Math.random())
          );
          colorAttr.setXYZ(idx, c.r, c.g, c.b);
          idx++;
        }
      }
      colorAttr.needsUpdate = true;

      arcGroup.add(packetMesh);
    }

    // Sample a point along arc polyline by param t in [0,1]
    function sampleArcPoint(arc, t, outVec) {
      const segs = arc.segments;
      const f = t * segs;
      const i = Math.floor(f);
      const u = f - i;

      const i0 = clamp(i, 0, segs);
      const i1 = clamp(i + 1, 0, segs);

      const base0 = i0 * 3;
      const base1 = i1 * 3;

      const x0 = arc.points[base0 + 0], y0 = arc.points[base0 + 1], z0 = arc.points[base0 + 2];
      const x1 = arc.points[base1 + 0], y1 = arc.points[base1 + 1], z1 = arc.points[base1 + 2];

      outVec.set(
        x0 + (x1 - x0) * u,
        y0 + (y1 - y0) * u,
        z0 + (z1 - z0) * u
      );
      return outVec;
    }

    // -----------------------------
    // Resize / Quality switching
    // -----------------------------
    let globeRadius = 1.35;

    function applyQuality(mode) {
  qualityMode = mode;
  const cfg = QUALITY[mode];

  const dpr = Math.min(window.devicePixelRatio || 1, cfg.dprCap);
  renderer.setPixelRatio(dpr);

  createStars(cfg.stars);
  globeRadius = createGlobe(cfg.globeSeg);

  // üî¥ DEBUG DOT ‚Äî NEW YORK CITY
  const dot = new THREE.Mesh(
    new THREE.SphereGeometry(0.03, 16, 16),
    new THREE.MeshBasicMaterial({ color: 0xff0000 })
  );
  latLonToVec3(40.71, -74.00, dot.position);
  //latLonToVec3(40.71, 74.00, dot.position);
  dot.position.multiplyScalar(globeRadius + 0.02);
  //globe.add(dot);

  createArcsAndPackets(globeRadius, cfg);

  const hudText = document.getElementById("hudText");
  hudText.textContent = `Quality: ${mode === "high" ? "High" : "Low"}`;
}


    function resize() {
  const w = window.innerWidth;
  const h = window.innerHeight;

  renderer.setSize(w, h, false);

  camera.aspect = w / h;

  // --- Auto-fit camera distance so globe fills the viewport nicely ---
  // We fit the sphere vertically AND horizontally (whichever is tighter).
  // globeRadius is in world units.
  const r = globeRadius;

  // Fraction of screen we want the globe diameter to occupy
  //const fill = 0.78; // 78% of min dimension feels "full" but not clipped

const hasBelowContent = window.innerHeight < 900;
const fill = hasBelowContent ? 0.62 : 0.78;


  const vFov = THREE.MathUtils.degToRad(camera.fov);
  const distV = (r / (fill * Math.tan(vFov / 2)));

  // Horizontal FOV depends on aspect
  const hFov = 2 * Math.atan(Math.tan(vFov / 2) * camera.aspect);
  const distH = (r / (fill * Math.tan(hFov / 2)));

  // Use whichever requires the camera to be farther away (prevents clipping)
  const targetDist = Math.max(distV, distH);

  // Keep your slight upward angle, but set distance on Z
  camera.position.set(0, 1.1, targetDist);

  // Keep OrbitControls limits sensible relative to targetDist
  controls.minDistance = targetDist * 0.62;
  controls.maxDistance = targetDist * 1.65;

  camera.updateProjectionMatrix();
}


    window.addEventListener("resize", resize, { passive: true });

    // -----------------------------
    // Motion + tab visibility
    // -----------------------------
    let running = true;
    document.addEventListener("visibilitychange", () => {
      running = !document.hidden;
    });


// ===== MODAL CONTENT =====
const securityHTML = `
<h2>QNTMail Security Model</h2>
<p>
QNTMail uses zero-trust, end-to-end cryptography. Servers never access plaintext.
</p>

<div class="modalSection">
<h3>Encryption</h3>
<ul class="modalList">
  <li>AES-256-GCM per message</li>
  <li>X25519 key exchange</li>
  <li>Ed25519 sender signatures</li>
  <li>Perfect Forward Secrecy</li>
</ul>
</div>

<div class="modalSection">
<h3>Infrastructure</h3>
<ul class="modalList">
  <li>Zero-knowledge storage</li>
  <li>No plaintext metadata</li>
  <li>Short-lived routing envelopes</li>
</ul>
</div>
`;

const networkHTML = `
<h2>Global Network</h2>
<p>Messages are routed via a distributed, latency-aware mesh.</p>
`;

const getStartedHTML = `
<h2>Get Started with QNTMail</h2>
<p>
QNTMail is currently in private preview. You can request access using an invite
code or sign in if you already have an account.
</p>

<!-- ===== PRIVATE ACCESS / BETA CODE ===== -->
<div class="modalSection">
  <h3>Private Access</h3>
  <p>
    If you received a private access or beta code, enter it below to begin
    onboarding.
  </p>

  <form class="waitlistForm" onsubmit="event.preventDefault();">
    <div class="waitlistField">
      <label class="waitlistLabel">Access code</label>
      <input
        type="text"
        class="waitlistInput"
        placeholder="QNT-XXXX-XXXX"
        autocomplete="off"
        spellcheck="false"
      />
    </div>

    <button type="submit" class="btn primary waitlistSubmit">
      Verify access code
    </button>

    <p class="fine" style="text-align:center;">
      Don‚Äôt have a code? Join the waitlist to request early access.
    </p>
  </form>
</div>

<!-- ===== EXISTING USER LOGIN ===== -->
<div class="modalSection">
  <h3>Existing Users</h3>
  <p>
    Already have a QNTMail account? Sign in below.
  </p>

  <form class="waitlistForm" onsubmit="event.preventDefault();">
    <div class="waitlistField">
      <label class="waitlistLabel">Email address</label>
      <input
        type="email"
        class="waitlistInput"
        placeholder="you@qntmail.com"
        autocomplete="email"
      />
    </div>

    <div class="waitlistField">
      <label class="waitlistLabel">Password</label>
      <input
        type="password"
        class="waitlistInput"
        placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
        autocomplete="current-password"
      />
    </div>

    <button type="submit" class="btn waitlistSubmit">
      Sign in
    </button>

    <p class="fine" style="text-align:center;">
      Login to manage your account.
    </p>
  </form>
</div>
`;


const waitlistHTML = `
<h2>Join the QNTMail Waitlist</h2>
<p>
Early access is prioritized for security-sensitive users and teams.
</p>

<form id="waitlistForm" class="waitlistForm">
  <div class="waitlistField">
    <label class="waitlistLabel">Email address</label>
    <input
      required
      type="email"
      name="email"
      class="waitlistInput"
      placeholder="you@domain.com"
      autocomplete="email"
    />
  </div>

  <div class="waitlistField">
    <label class="waitlistLabel">Intended use (optional)</label>
    <input
      type="text"
      name="usecase"
      class="waitlistInput"
      placeholder="Personal, Company, Research"
    />
  </div>

  <button type="submit" class="btn primary waitlistSubmit">
    Join waitlist
  </button>
</form>
`;




    // -----------------------------
    // Interactions / CTAs
    // -----------------------------
    document.getElementById("year").textContent = String(new Date().getFullYear());

    document.getElementById("ctaPrimary").addEventListener("click", () => {
  openModal(waitlistHTML);
});

document.querySelector('[href="#security"]').addEventListener("click", e => {
  e.preventDefault();
  openModal(securityHTML);
});

document.getElementById("ctaSecondary").addEventListener("click", () => {
  openModal(securityHTML);
});

document.querySelector('[href="#network"]').addEventListener("click", e => {
  e.preventDefault();
  openModal(networkHTML);
});

document.querySelector('[href="#get-started"]').addEventListener("click", e => {
  e.preventDefault();
  openModal(getStartedHTML);
});


    document.getElementById("ctaSecondary").addEventListener("click", () => {
      const el = document.getElementById("security");
      el?.scrollIntoView({ behavior: "smooth", block: "start" });
    });

    document.getElementById("toggleQuality").addEventListener("click", () => {
      applyQuality(qualityMode === "high" ? "low" : "high");
      resize();
    });

    document.getElementById("toggleMotion").addEventListener("click", () => {
      motionEnabled = !motionEnabled;
      document.getElementById("toggleMotion").textContent = motionEnabled ? "Motion" : "Paused";
    });

    // -----------------------------
    // Animate loop (efficient)
    // -----------------------------
    const clock = new THREE.Clock();

    // Some gentle globe auto-rotation
    let autoRot = 0;

    function tick() {
      requestAnimationFrame(tick);
      if (!running) return;

      const dt = clamp(clock.getDelta(), 0, 0.033); // cap delta for stability

      controls.update();

      // Subtle star drift
      if (stars) stars.rotation.y += dt * 0.02;

      // Globe rotates slightly unless user is actively dragging (OrbitControls doesn't expose directly; we keep it subtle)
      autoRot += dt * 0.25;
      globe.rotation.y = autoRot;
      gridLines.rotation.y = globe.rotation.y * 1.02;
      atmosphere.rotation.y = globe.rotation.y * 0.98;

      // Animate packets (instanced updates only)
      if (packetMesh && motionEnabled) {
        const count = packetMesh.count;
        const m = packetMesh.instanceMatrix;

        // Per-frame dynamic intensity pulse
        const pulse = 0.65 + 0.35 * Math.sin(autoRot * 1.4);

        for (let i = 0; i < count; i++) {
          const aIdx = packetData.arcIndex[i];
          const arc = arcs[aIdx];

          // Advance phase
          let phase = packetData.phase[i];
          phase = (phase + dt * arc.speed * packetData.speedMul[i]) % 1;
          packetData.phase[i] = phase;

          // Position on arc
          sampleArcPoint(arc, (phase + arc.offset) % 1, _tmp);

          // Look-ahead for orientation
          const aheadT = (phase + arc.offset + 0.01) % 1;
          sampleArcPoint(arc, aheadT, _tmp2);

          // Direction
          _tmp2.sub(_tmp).normalize();

          // Build rotation to face movement direction
          //_quat.setFromUnitVectors(_up, _tmp2); // aligns Y axis to direction
          
		  const _lookMat = new THREE.Matrix4();

_lookMat.lookAt(
  _tmp,
  _tmp2.add(_tmp),
  _up
);
_quat.setFromRotationMatrix(_lookMat);


		  
		  
		  
		  _mat4.makeRotationFromQuaternion(_quat);

          // Scale with pulse and mild per-packet variance
          const s = 1.0 + 0.22 * pulse * (0.5 + 0.5 * packetData.opacity[i]);
          _mat4.scale(_v3.set(s, s, s));

          // Add subtle lateral jitter (tiny)
          // Jitter direction is roughly orthogonal: cross(dir, up-ish)
          _v1.copy(_tmp2).cross(_up).normalize();
          const j = (Math.sin((phase * 6.283) + packetData.jitter[i] * 10.0) * 0.5 + 0.5) * 0.015;
          //_tmp.addScaledVector(_v1, j);
		  

          // Set translation
          _mat4.setPosition(_tmp);

          packetMesh.setMatrixAt(i, _mat4);
        }

        m.needsUpdate = true;

        // Material opacity pulse (cheap)
        packetMesh.material.opacity = 0.72 + 0.20 * pulse;
      }

      renderer.render(scene, camera);
    }

    // -----------------------------
    // Init
    // -----------------------------
    resize();
    applyQuality(prefersReducedMotion ? "low" : "high");

    // If reduced motion, start paused (but allow user toggle)
    if (prefersReducedMotion) {
      motionEnabled = false;
      document.getElementById("toggleMotion").textContent = "Paused";
    }

    tick();
  </script>
</body>
</html>
